{"version":3,"file":"996.bundle.js","mappings":"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","sources":["webpack://babylonjs/./src/controllers/PlayerController.ts","webpack://babylonjs/./src/scene.ts"],"sourcesContent":["import { AbstractMesh, Vector3, Axis, CreateDecal, SceneLoader, } from \"@babylonjs/core\";\nclass Player extends AbstractMesh {\n    constructor(camera, playerMesh, splatters, scene) {\n        super(\"player-wrapper\");\n        /**\n         * Двигается ли игрок вперед?\n         */\n        this._movingForward = false;\n        /**\n         * Двигается ли игрок назад?\n         */\n        this._movingBack = false;\n        /**\n         * Двигается ли игрок влево?\n         */\n        this._movingLeft = false;\n        /**\n         * Двигается ли игрок вправо?\n         */\n        this._movingRight = false;\n        /**\n         * Рост игрока\n         */\n        this._characterHeight = 1.8;\n        /**\n         * Бежит ли игрок?\n         */\n        this._isRunning = false;\n        /**\n         * Скорость ходьбы\n         */\n        this._walkSpeed = 10;\n        /**\n         * Скорость бега\n         */\n        this._runSpeed = 25;\n        this._camera = camera;\n        this._playerMesh = playerMesh;\n        this._splatters = splatters;\n        this._scene = scene;\n        this._playerWrapper = this;\n        this._playerMesh.setParent(this._playerWrapper);\n        this._playerMesh.isVisible = false;\n        this._camera.parent = this._playerMesh;\n        this._camera.position.y = this._characterHeight;\n        this._listenEvents();\n        this._calculateMovement();\n        this._calculateShoot();\n    }\n    async loadWeapon() {\n        const { meshes } = await SceneLoader.ImportMeshAsync(\"\", \"./models/\", \"paintball_gun.glb\");\n        this._weapon = meshes[0];\n        this._weapon.setParent(this._camera);\n        this._weapon.position = new Vector3(0.87, -0.54, 1.25);\n    }\n    _calculateShoot() {\n        this._scene.onPointerDown = (e) => {\n            if (e.inputIndex === 2) {\n                const ray = this._camera.getForwardRay(undefined, undefined, this._playerWrapper\n                    .getAbsolutePosition()\n                    .add(new Vector3(0, this._characterHeight, 0)));\n                const raycastHit = this._scene.pickWithRay(ray);\n                if (raycastHit.hit) {\n                    const decal = CreateDecal(\"decal\", raycastHit.pickedMesh, {\n                        position: raycastHit.pickedPoint,\n                        normal: raycastHit.getNormal(true),\n                        size: new Vector3(1, 1, 1),\n                    });\n                    decal.material =\n                        this._splatters[Math.floor(Math.random() * this._splatters.length)];\n                    decal.setParent(raycastHit.pickedMesh);\n                }\n            }\n        };\n    }\n    _calculateMovement() {\n        this._scene.registerBeforeRender(() => {\n            /**\n             * Количество времени (в секундах), которое прошло между текущим и предыдущим кадром (фреймом)\n             */\n            const deltaTime = this._scene.getEngine().getDeltaTime() / 1000;\n            const cameraDirection = this._camera\n                .getDirection(Vector3.Forward())\n                .normalizeToNew();\n            const currentSpeed = this._isRunning ? this._runSpeed : this._walkSpeed;\n            if (this._movingForward) {\n                this._playerWrapper.moveWithCollisions(cameraDirection.scale(currentSpeed * deltaTime));\n            }\n            if (this._movingBack) {\n                this._playerWrapper.moveWithCollisions(cameraDirection.scale(-currentSpeed * 0.6 * deltaTime));\n            }\n            if (this._movingLeft) {\n                this._playerWrapper.moveWithCollisions(cameraDirection.cross(Axis.Y).scale(currentSpeed * deltaTime));\n            }\n            if (this._movingRight) {\n                this._playerWrapper.moveWithCollisions(cameraDirection.cross(Axis.Y).scale(-currentSpeed * deltaTime));\n            }\n            this._playerWrapper.position.y = this._characterHeight / 2 + 0.2;\n        });\n    }\n    _listenEvents() {\n        const canvas = this._scene.getEngine().getRenderingCanvas();\n        canvas.addEventListener(\"keydown\", (event) => {\n            switch (event.code) {\n                case \"KeyW\":\n                    this._movingForward = true;\n                    break;\n                case \"KeyS\":\n                    this._movingBack = true;\n                    break;\n                case \"KeyA\":\n                    this._movingLeft = true;\n                    break;\n                case \"KeyD\":\n                    this._movingRight = true;\n                    break;\n                case \"ShiftLeft\":\n                    this._isRunning = true;\n                    this._weapon.rotate(Axis.X, Math.PI / 4);\n                    break;\n            }\n        });\n        canvas.addEventListener(\"keyup\", (event) => {\n            switch (event.code) {\n                case \"KeyW\":\n                    this._movingForward = false;\n                    break;\n                case \"KeyS\":\n                    this._movingBack = false;\n                    break;\n                case \"KeyA\":\n                    this._movingLeft = false;\n                    break;\n                case \"KeyD\":\n                    this._movingRight = false;\n                    break;\n                case \"ShiftLeft\":\n                    this._isRunning = false;\n                    this._weapon.rotate(Axis.X, -Math.PI / 4);\n                    break;\n            }\n        });\n    }\n}\nexport default Player;\n","import { UniversalCamera, Color4, Vector3, HemisphericLight, SceneLoader, CreateSphere, Texture, StandardMaterial, CreateBox, ArcRotateCamera, } from \"@babylonjs/core\";\nimport { AdvancedDynamicTexture, Rectangle } from \"@babylonjs/gui\";\nimport * as GUI from \"@babylonjs/gui\";\nimport \"@babylonjs/inspector\";\nimport \"@babylonjs/loaders\";\nimport PlayerController from \"./controllers/PlayerController\";\nexport async function initScene(scene) {\n    scene.getEngine().displayLoadingUI();\n    const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\n    light.intensity = 0.7;\n    const camera = setUpCamera(scene);\n    const debugCamera = new ArcRotateCamera(\"camera\", Math.PI, Math.PI / 4, 20, Vector3.Zero());\n    const ui = setUpUI();\n    await createEnviroment(scene);\n    const splatters = createTexture();\n    const playerMesh = CreateBox(\"player-mesh\");\n    const player = new PlayerController(camera, playerMesh, splatters, scene);\n    await player.loadWeapon();\n    scene.clearColor = new Color4(0.75, 0.75, 0.9, 1.0);\n    scene.collisionsEnabled = true;\n    const sphere = CreateSphere(\"sphere\", { diameter: 5 }, scene);\n    sphere.checkCollisions = true;\n    sphere.position = new Vector3(0, 2.5, 5);\n    scene.onBeforeRenderObservable.add(() => {\n        const dot = findDotProductBetween(camera, sphere);\n        changeColorForCrosshair(ui.crosshair, dot);\n        ui.vectorComparator.dotBarInner.width = `${Math.floor((dot + 1) * 100)}px`;\n    });\n    window.addEventListener(\"keydown\", (event) => {\n        //Ctrl+I\n        if (event.ctrlKey && event.keyCode === 73) {\n            if (scene.debugLayer.isVisible()) {\n                scene.debugLayer.hide();\n            }\n            else {\n                scene.debugLayer.show();\n            }\n        }\n    });\n    scene.getEngine().hideLoadingUI();\n}\nfunction createTexture() {\n    const blue = new StandardMaterial(\"blue\");\n    const orange = new StandardMaterial(\"orange\");\n    const green = new StandardMaterial(\"green\");\n    blue.diffuseTexture = new Texture(\"./textures/blue.png\");\n    orange.diffuseTexture = new Texture(\"./textures/orange.png\");\n    green.diffuseTexture = new Texture(\"./textures/green.png\");\n    blue.diffuseTexture.hasAlpha = true;\n    orange.diffuseTexture.hasAlpha = true;\n    green.diffuseTexture.hasAlpha = true;\n    blue.zOffset = -1;\n    orange.zOffset = -1;\n    green.zOffset = -1;\n    blue.roughness = 1;\n    orange.roughness = 1;\n    green.roughness = 1;\n    return [blue, orange, green];\n}\nfunction findDotProductBetween(camera, mesh) {\n    const cameraDirection = camera\n        .getDirection(Vector3.Forward())\n        .normalizeToNew();\n    const sphereVec = mesh.position.subtract(camera.position).normalizeToNew();\n    return Vector3.Dot(cameraDirection, sphereVec);\n}\nfunction changeColorForCrosshair(crosshair, dot) {\n    let color = \"white\";\n    if (dot > 0.9) {\n        color = \"green\";\n    }\n    else if (dot > 0.5) {\n        color = \"yellow\";\n    }\n    else {\n        color = \"red\";\n    }\n    crosshair.xRect.color = crosshair.yRect.color = color;\n}\nfunction setUpCamera(scene) {\n    const camera = new UniversalCamera(\"camera\", new Vector3(0, 8, 0), scene);\n    camera.attachControl();\n    // camera.position = new Vector3(0, 4, -15);\n    // camera.applyGravity = true;\n    // camera.checkCollisions = true;\n    // (camera as any)._needMoveForGravity = true;\n    // camera.ellipsoid = new Vector3(0.9, 1.8, 0.9);\n    // camera.minZ = 0.05;\n    // camera.speed = 0.45;\n    // camera.angularSensibility = 4000;\n    // camera.keysUp.push(87);\n    // camera.keysLeft.push(65);\n    // camera.keysDown.push(83);\n    // camera.keysRight.push(68);\n    return camera;\n}\nfunction setUpUI() {\n    const tex = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\n    const crosshairColor = \"white\";\n    const xRect = new Rectangle(\"xRect\");\n    xRect.width = \"20px\";\n    xRect.height = \"2px\";\n    xRect.color = crosshairColor;\n    tex.addControl(xRect);\n    const yRect = new Rectangle(\"yRect\");\n    yRect.width = \"2px\";\n    yRect.height = \"20px\";\n    yRect.color = crosshairColor;\n    tex.addControl(yRect);\n    const dotBar = new Rectangle(\"dotBar\");\n    dotBar.horizontalAlignment = GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    dotBar.verticalAlignment = GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n    dotBar.top = \"-20px\";\n    dotBar.width = \"200px\";\n    dotBar.height = \"40px\";\n    dotBar.background = \"grey\";\n    tex.addControl(dotBar);\n    const dotBarInner = new Rectangle(\"dotBarInner\");\n    dotBarInner.horizontalAlignment = GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    dotBarInner.verticalAlignment = GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    dotBarInner.width = \"100px\";\n    dotBarInner.height = \"40px\";\n    dotBarInner.background = \"green\";\n    dotBar.addControl(dotBarInner);\n    return {\n        crosshair: {\n            xRect,\n            yRect,\n        },\n        vectorComparator: {\n            dotBarInner,\n        },\n    };\n}\nasync function createEnviroment(scene) {\n    const { meshes } = await SceneLoader.ImportMeshAsync(\"\", \"./models/\", \"Prototype_Level.glb\", scene);\n    meshes.forEach((mesh) => {\n        mesh.checkCollisions = true;\n        if (mesh.name === \"Ramp\") {\n            mesh.isVisible = false;\n            mesh.checkCollisions = false;\n        }\n    });\n}\n"],"names":["Player","AbstractMesh","constructor","camera","playerMesh","splatters","scene","super","this","_movingForward","_movingBack","_movingLeft","_movingRight","_characterHeight","_isRunning","_walkSpeed","_runSpeed","_camera","_playerMesh","_splatters","_scene","_playerWrapper","setParent","isVisible","parent","position","y","_listenEvents","_calculateMovement","_calculateShoot","async","meshes","SceneLoader","_weapon","Vector3","onPointerDown","e","inputIndex","ray","getForwardRay","undefined","getAbsolutePosition","add","raycastHit","pickWithRay","hit","decal","CreateDecal","pickedMesh","pickedPoint","normal","getNormal","size","material","Math","floor","random","length","registerBeforeRender","deltaTime","getEngine","getDeltaTime","cameraDirection","getDirection","normalizeToNew","currentSpeed","moveWithCollisions","scale","cross","Axis","canvas","getRenderingCanvas","addEventListener","event","code","rotate","PI","initScene","displayLoadingUI","HemisphericLight","intensity","UniversalCamera","attachControl","setUpCamera","ui","ArcRotateCamera","tex","AdvancedDynamicTexture","crosshairColor","xRect","Rectangle","width","height","color","addControl","yRect","dotBar","horizontalAlignment","verticalAlignment","top","background","dotBarInner","crosshair","vectorComparator","setUpUI","forEach","mesh","checkCollisions","name","createEnviroment","blue","StandardMaterial","orange","green","diffuseTexture","Texture","hasAlpha","zOffset","roughness","createTexture","CreateBox","player","PlayerController","loadWeapon","clearColor","Color4","collisionsEnabled","sphere","CreateSphere","diameter","onBeforeRenderObservable","dot","sphereVec","subtract","findDotProductBetween","changeColorForCrosshair","window","ctrlKey","keyCode","debugLayer","hide","show","hideLoadingUI"],"sourceRoot":""}